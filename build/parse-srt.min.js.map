{"version":3,"sources":["parse-srt.js"],"names":["global","factory","exports","module","define","amd","parseSRT","this","toSeconds","time","t","split","s","length","parseFloat","e","nextNonEmptyLine","linesArray","position","idx","lastNonEmptyLine","data","arguments","undefined","options","propName","subs","lines","endIdx","text","sub","i","id","parseInt","start","timeInText","indexOf","substr","end","push","textPropName","join","replace","ignoreLineBreaks"],"mappings":"CAAC,SAAUA,EAAQC,GACE,gBAAZC,UAA0C,mBAAXC,QAAyBA,OAAOD,QAAUD,IAC9D,kBAAXG,SAAyBA,OAAOC,IAAMD,OAAOH,GACnDD,EAAOM,SAAWL,KACnBM,KAAM,WAAe;;;;;;;;AAWvB,QAASC,GAAUC,GACjB,GAAIC,GAAID,EAAKE,MAAM,IAEnB,KACE,GAAIC,GAAIF,EAAE,GAAGC,MAAM,IAMnB,OAJiB,KAAbC,EAAEC,SACJD,EAAIF,EAAE,GAAGC,MAAM,MAGa,KAAvBG,WAAWJ,EAAE,GAAI,IAAoC,GAAvBI,WAAWJ,EAAE,GAAI,IAAWI,WAAWF,EAAE,GAAI,IAAME,WAAWF,EAAE,GAAI,IAAM,IAC/G,MAAOG,GACP,MAAO,IAIX,QAASC,GAAiBC,EAAYC,GAGpC,IAFA,GAAIC,GAAMD,GAEFD,EAAWE,IACjBA,GAGF,OAAOA,GAGT,QAASC,GAAiBH,GAGxB,IAFA,GAAIE,GAAMF,EAAWJ,OAAS,EAEvBM,GAAO,IAAMF,EAAWE,IAC7BA,GAGF,OAAOA,GAGT,QAASb,KAYP,IAAK,GAXDe,GAAOC,UAAUT,OAAS,OAAsBU,KAAjBD,UAAU,GAAmBA,UAAU,GAAK,GAC3EE,EAAUF,UAAUT,OAAS,OAAsBU,KAAjBD,UAAU,GAAmBA,UAAU,IAAOG,aAEhFC,KACAC,EAAQN,EAAKV,MAAM,oBACnBiB,EAASR,EAAiBO,GAAS,EACnCR,EAAM,EACNV,MAAO,GACPoB,MAAO,GACPC,MAAM,GAEDC,EAAI,EAAGA,EAAIH,EAAQG,IAAK,CAiB/B,IAhBAD,KACAD,KAEAE,EAAIf,EAAiBW,EAAOI,GAC5BD,EAAIE,GAAKC,SAASN,EAAMI,KAAM,IAE9BtB,EAAOkB,EAAMI,KAAKpB,MAAM,mBAExBmB,EAAIN,EAAQC,SAASS,OAAS,SAAWV,EAAQW,WAAa1B,EAAK,GAAKD,EAAUC,EAAK,IAEvFU,EAAMV,EAAK,GAAG2B,QAAQ,MACT,IAATjB,IACFV,EAAK,GAAKA,EAAK,GAAG4B,OAAO,EAAGlB,IAE9BW,EAAIN,EAAQC,SAASa,KAAO,OAASd,EAAQW,WAAa1B,EAAK,GAAKD,EAAUC,EAAK,IAE5EsB,EAAIH,GAAUD,EAAMI,IACzBF,EAAKU,KAAKZ,EAAMI,KAGlB,IAAIS,GAAehB,EAAQC,SAASI,MAAQ,MAE5CC,GAAIU,GAAgBX,EAAKY,KAAK,KAAKC,QAAQ,qCAAsC,GAIjFZ,GAAIU,GAAgBV,EAAIU,GAAcE,QAAQ,KAAM,QAAQA,QAAQ,KAAM,QAE1EZ,EAAIU,GAAgBV,EAAIU,GAAcE,QAAQ,uGAAwG,YAEjJlB,EAAQmB,iBAAwFb,EAAIU,GAAgBV,EAAIU,GAAcE,QAAQ,QAAS,IAA7HZ,EAAIU,GAAgBV,EAAIU,GAAcE,QAAQ,QAAS,UAEtFhB,EAAKa,KAAKT,GAGZ,MAAOJ,GAGT,MAAOpB","file":"parse-srt.min.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.parseSRT = factory());\n}(this, (function () { 'use strict';\n\n/**\n * @name parseSRT\n * @desc Parses and converts SRT subtitle data into JSON format. Adapted from the popcorn.js SRT parser plugin.\n * @see http://github.com/NewtopiaDEV\n * @author Newtopia Dev (http://www.newtopia.com)\n * @version 1.0.1\n * @license MIT\n */\n\nfunction toSeconds(time) {\n  var t = time.split(':');\n\n  try {\n    var s = t[2].split(',');\n\n    if (s.length === 1) {\n      s = t[2].split('.');\n    }\n\n    return parseFloat(t[0], 10) * 3600 + parseFloat(t[1], 10) * 60 + parseFloat(s[0], 10) + parseFloat(s[1], 10) / 1000;\n  } catch (e) {\n    return 0;\n  }\n}\n\nfunction nextNonEmptyLine(linesArray, position) {\n  var idx = position;\n\n  while (!linesArray[idx]) {\n    idx++;\n  }\n\n  return idx;\n}\n\nfunction lastNonEmptyLine(linesArray) {\n  var idx = linesArray.length - 1;\n\n  while (idx >= 0 && !linesArray[idx]) {\n    idx--;\n  }\n\n  return idx;\n}\n\nfunction parseSRT() {\n  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { propName: {} };\n\n  var subs = [];\n  var lines = data.split(/(?:\\r\\n|\\r|\\n)/gm);\n  var endIdx = lastNonEmptyLine(lines) + 1;\n  var idx = 0;\n  var time = void 0;\n  var text = void 0;\n  var sub = void 0;\n\n  for (var i = 0; i < endIdx; i++) {\n    sub = {};\n    text = [];\n\n    i = nextNonEmptyLine(lines, i);\n    sub.id = parseInt(lines[i++], 10);\n\n    time = lines[i++].split(/[\\t ]*-->[\\t ]*/);\n\n    sub[options.propName.start || 'start'] = options.timeInText ? time[0] : toSeconds(time[0]);\n\n    idx = time[1].indexOf(' ');\n    if (idx !== -1) {\n      time[1] = time[1].substr(0, idx);\n    }\n    sub[options.propName.end || 'end'] = options.timeInText ? time[1] : toSeconds(time[1]);\n\n    while (i < endIdx && lines[i]) {\n      text.push(lines[i++]);\n    }\n\n    var textPropName = options.propName.text || 'text';\n\n    sub[textPropName] = text.join(' ').replace(/\\{(\\\\[\\w]+\\(?([\\w\\d]+,?)+\\)?)+\\}/gi, '');\n\n    var x = 'asdf';\n\n    sub[textPropName] = sub[textPropName].replace(/</g, '&lt;').replace(/>/g, '&gt;');\n\n    sub[textPropName] = sub[textPropName].replace(/&lt;(\\/?(font|b|u|i|s))((\\s+(\\w|\\w[\\w\\-]*\\w)(\\s*=\\s*(?:\".*?\"|'.*?'|[^'\">\\s]+))?)+\\s*|\\s*)(\\/?)&gt;/gi, '<$1$3$7>');\n\n    if (!options.ignoreLineBreaks) sub[textPropName] = sub[textPropName].replace(/\\\\N/gi, '<br />');else sub[textPropName] = sub[textPropName].replace(/\\\\N/gi, '');\n\n    subs.push(sub);\n  }\n\n  return subs;\n}\n\nreturn parseSRT;\n\n})));\n//# sourceMappingURL=parse-srt.js.map\n"]}